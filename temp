import process = require("process");
import fs = require("fs");
import { MongoClient, Collection, Db, ObjectID as objId } from "mongodb";
import csvConvertor = require("json-2-csv");
import * as utils from "./utils";

// eslint-disable-next-line @typescript-eslint/no-var-requires
const xlsxConvertor = require("json-as-xlsx");

interface document {
  [key: string]:
    | objId
    | string
    | number
    | boolean
    | null
    | document
    | Array<document>;
}
type documents = Array<document>;
interface dataDump {
  [key: string]: documents;
}

interface downloadI {
  mongoURI: string;
  database: string;
  type: "json" | "csv" | "excel";
}

export default async function downloadDatabase(
  params: downloadI,
): Promise<void> {
  const { mongoURI, database, type } = params;

  const client: MongoClient = new MongoClient(mongoURI, {
    useUnifiedTopology: true,
  });

  try {
    console.log("Connecting to Mongo Server......");
    await client.connect();
    await client.db("admin").command({ ping: 1 });
    console.log("Connected successfully to Mongo Server");

    const db: Db = await client.db(database);
    const adminDb = client.db().admin();

    // List all the available databases
    const fetchDbs = await adminDb.listDatabases();
    let exists = false;
    let isEmpty = false;
    for (const dbObject of fetchDbs.databases) {
      if (database === dbObject.name) {
        exists = true;
        isEmpty = dbObject.empty;
        break;
      }
    }
    if (!exists) {
      console.log(`Database ${database} not found`);
      return;
    }
    if (isEmpty) {
      console.log(`Database ${database} is empty`);
      return;
    }

    const collectionsArray = await db.listCollections().toArray();
    if (collectionsArray.length === 0) {
      console.log(`No Collections found in database ${database}`);
      return;
    }
    const dbDir = `${process.cwd()}/${database}_${params.type}`;
    if (type === "excel" || type === "csv") {
      if (!fs.existsSync(dbDir)) {
        fs.mkdirSync(dbDir);
      }
    }
    const data: dataDump = {};
    console.log(`Exporting ${collectionsArray.length} collections as ${type}`);

    await collectionsArray.forEach(
      async (collectionObj): Promise<void> => {
        const collection: Collection = db.collection(collectionObj.name);
        let records: documents = await collection.find({}).toArray();
        if (type === "excel" || type === "csv") {
          records = utils.preprocessRecords(records);
        }
        data[collectionObj.name] = records;
      },
    );
    switch (type) {
      case "csv":
        Object.keys(data).forEach(
          async (collectionName: string): Promise<void> => {
            console.log(collectionName);
            csvConvertor.json2csv(
              data[collectionName],
              (err: Error | undefined, csv: string | undefined): void => {
                //need to be looked at
                csv = (csv as string).replace(/undefined/g, "<UNDEFINED>");

                if (err) throw err;
                fs.writeFile(
                  `${dbDir}/${collectionName}.csv`,
                  csv,
                  "utf8",
                  function (error): void {
                    if (error) {
                      console.log(
                        `${collectionName}.csv Some error occured - file either not saved or corrupted file saved.`,
                      );
                    } else {
                      // console.log(`${collectionName}.csv Saved Successfully`);
                    }
                  },
                );
              },
            );
          },
        );
        break;
      case "excel":
        Object.keys(data).forEach(
          async (collectionName: string): Promise<void> => {
            try {
              if (data[collectionName].length == 0) {
                console.error(`Collection ${collectionName} is empty`);
                return;
              }
              const columns: Array<Record<string, string>> = [];
              Object.keys(data[collectionName][0]).map((key: string): void => {
                columns.push({ label: key, value: key });
              });
              const xlsxSettings: Record<string, string | number> = {
                fileName: `${dbDir}/${collectionName}`,
              };
              xlsxConvertor(columns, data[collectionName], xlsxSettings, true);
              // console.log(`${collectionName}.xlsx Saved Successfully`);
            } catch (e) {
              console.error(`export error in ${collectionName}`, e);
            }
          },
        );
        break;
      case "json":
        try {
          const file: number = fs.openSync(`${database}.json`, "w");
          fs.writeFileSync(file, JSON.stringify(data));
          // console.log(`${collectionName}.json Saved Successfully`);
          fs.close(file, () => {
            //
          });
        } catch (err) {
          console.error("export error", err);
        }
        break;

      default:
        console.log(
          "Invalid Export Format Specified\nSpeifiy one of the three : json | csv| excel ",
        );
        return;
    }
    console.log(
      `Database ${database} exported as ${type} successfully at location : ${dbDir}`,
    );
  } catch (err) {
    console.log(err);
  }
}
